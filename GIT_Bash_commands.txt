#-----------------------ЗНАКОМСТВО С КОМАНДАМИ GIT и BASH-------------------------
#--------------------------------Данильченко Вадим--------------------------------
#------------по материалу из githowto.com и других открытых источников------------
#-под Windows буду использовать GIT Bash. Скачан: https://git-scm.com/download/win-
#------------------ описал ровно насколько понял, новичок -------------------------

--задаем имя пользователя и имейл
git config --global user.name "Vndanilchenko"
git config --global user.email "vndanilchenko@gmail.com"

----сделаем некоторые дополнительные настройки
----уберем ошибку о наличии в файле разрыва строки
----git config --global core.safecrlf true
------git config --global core.safecrlf false
----git config --global core.autocrlf true
----установка отображения unicode
----git config --global core.quotepath off

--создам директорию NETOLOGY, в которой буду хранить данные по процессу обучения
mkdir NETOLOGY

----если появится необходимость удалить ее, можно воспользоваться командой, удаляющей ее со всем содержимым
----rm NETOLOGY -r

--перейду в созданную папку
cd NETOLOGY

---- если бы она была одна, можно было бы ее не записывать, а указать звездочку (также можно начать писать название файла и нажать TAB - название подставится автоматически)
---- cd *
---- вернуться на уровень вверх
---- cd .. (или cd -)
---- вернуться на два уровня вверх
---- cd ../..
---- вернуться в корень
---- cd ~
---- перейти в другую директорию
---- cd ../test_dir/test_dir2

--инициализируем git репозиторий в выбранной для работы директории
git init

----конфигурационный файл можно просмотреть так
----cat .git/config

--проверим содержимое папки
ls

---- можно проверить содержимое другой директории, достаточно указать путь
---- ls ../test_dir/test_dir2

--создадим файл
touch test.txt

---- удалить его можно командой rm
---- rm test.txt
---- переместить командой mv
---- mv test.txt test_dir
---- посмотреть содержимое файла
---- cat test.txt

-- проверим статус, файл должен появиться в предложении к индексированию для дальнешего коммита
git status

-- проиндексируем файл, чтобы со следующим коммитом он был был добавлен в историю изменений
git add test.txt

---- можно проиндексировать сразу все изменения (точка после пробела обязательна)
---- git add .

-- сделаем коммит по файлу, добавив комментарий к записи (-m, иначе будет открыт редактор с предложением сделать коммент, для него ESC, потом :wq)
git commit -m "Any comment about commit"

-- посмторим историю коммитов
git log

-- присвоим метку этому коммиту
git tag v1

---- можно удалить метку
---- git tag -d v1
---- чтобы посмотреть все метки
---- git tag
---- хэш можно найти в системных файлах репозитория
---- cat .git/refs/tags/v1


--коммиты будут содержать информацию о состоянии репозитория в момент создания записи
--мы можем посмотреть скажем содержимое файла в некотором коммите ранее, для этого надо указать хэш или метку коммита и перейти в эту точку
git checkout v1 (метка или хэш)

----перместиться в самый последний коммит ветки можно командой
----git checkout master
----создать ветку и сразу в нее перейти
----git checkout -b new_branch

--если у нас есть файл, который еще не проиндексирован и не закомитчен, и он мы хотим убрать его из буферной зоны, то можно сделать так:
git checkout файл --произойдет отмена изменений в файле, status покажет, что ысе чисто
--если у нас есть проиндексированный файл, и мы не хотим его коммитить, то откатить можно в два этапа
git reset HEAD файл
git checkout файл
--чтобы откатить последние изменения после коммита, надо выполнить команду
git revert HEAD --no-edit (--no-edit не позволит запустить редактор и оставит коммент об удалении по умолчанию)
--чтобы откатиться на несколько коммитов назад, нужно выбрать метку или хэш нужного коммита и указать в команде
git reset --hard v1 (метка или хэш коммита)
--чтобы перезаписать последний коммит при незначительных изменениях, используем --amend
git commit --amend -m "Any comment about commit"

--зададим алиасы на команды
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"

----теперь вместо длинной команды с форматом вывода данных выводить коротко
----git hist
------если нужно посмотреть полный список коммитов
------git hist --all
------если нужно посмотреть 2 последние записи
------git hist --max-count=2

--объединение версий коммитов для разных ветвей (предпочтительно в сравнении с rebase)
git merge master
--перебазирование версий коммитов одной ветки в другую (не так предпочтительно)
git rebase master

--копирование репозитория со всеми файлами и папками (например, из dir в new_dir)
git clone dir new_dir

--чтобы начать отслеживать какую-то ветвь (например, для отслеживания ветви origin/style создадим ветвь style в нашем репо)
git branch --track style origin/style

--посмотреть список всех удаленных (расположенных удаленно, возможно скопированных некоторое время назад) репозиториев/серверов
git remote

-- для просмотра статистики по репо
git remote show origin

--посмотреть список всех локальных веток
git branch

----список всех веток -a (равноценно --all)
----git branch -a 

--чтобы накатить изменения из удаленного репозитория в локальный, есть 2 варианта
--1. сначала скопировать список коммитов без изменения файлов, а потом залить соответствующие состоянию файлы
git fetch
git merge origin/master
--2. использовать одну команду, выполняющую сразу 2 этих действия (если не указывать ветку, то зальется изменение всех ветвей)
git pull 

----чтобы залить какую-то конкретную ветвь
----git pull shared master

--чтобы правильно вести и отслеживать версионность в команде или просто на разных ресурсах лучше создать общий репо, 
--в котором будут хранить записи обо всех нужных коммитах и с него все остальные будут накатывать нужные изменения
--создадим пустой репозиторий, скопировав в него системные файлы репозитория hello, версии коммитов будут при этом скопированы, 
--но сами файлы нет (принято, что имеет имя: имя.git)
git clone --bare hello hello.git
--укажем, что этот пустой репо является общим для нашей ветви (указываем полное расположение)
git remote add shared ../hello.git
--чтобы отправить в общий репо данные о новых коммитах, нужно выполнить команду
git push shared master --в данном случае передаем данные в ветвь master репозитория shared (путь к которому указали ранее)
---- если передаем данные об изменениях в репозиторий на GitHub впервые, нужно также указать, какая удаленная ветвь будет по умолчанию
---- для текущей локальной ветки, используем --set-upstream, последующие pull будут фиксироваться в нее
---- git push --set-upstream https://github.com/Vndanilchenko/EXPLORE_LATER master
--! перед push-ем не забываем делать pull
--если вдруг понадобилось объединить два проекта, которые какое-то время назад начали жить независимо 
--(понадобилось после внесения отдельных изменений одного репо на GitHub и локально, pull ругался на конфликт несвязанных историй)
git --work-tree="." pull --allow-unrelated-histories https://github.com/Vndanilchenko/GIT-BASH-COMMANDS

